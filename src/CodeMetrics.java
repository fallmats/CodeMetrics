// CodeMetrics
// TODO: Support excluding files or folders. This is useful if parts of your source code was generated by a tool.
// -e PATH1_TO_EXCLUDE;PATH2_TO_EXCLUDE
// TODO: Support for defining components/modules
// -m module1=PATH1;PATH2 module2=PATH3
// TODO: Support for (Java done?), C#, C++, XML
// TODO: Create interface so we can handle different type of files mentioned above

import java.io.File;

import se.prolore.fileparsing.SourceFiles;
import se.prolore.graphics.XYPlotCodeChurn;


public class CodeMetrics {
    private boolean calculateCodeChurn = false;
    private SourceFiles oldFiles = null;
    private SourceFiles newFiles = null;
    private File oldFile = null;
    private File newFile = null;

    static private String usage =
            "Usage: CodeMetrics file [-options]\n" +
                    "  (to calculate metrics for a single source file)\n" +
                    "or  CodeMetrics path [-options]\n" +
                    "  (to traverse a directory and calculate metrics for all source files)\n" +
                    "or  CodeMetrics oldfile newfile [-options]\n" +
                    "  (to calculate metrics including code churn)\n" +
                    "\n" +
                    "where options include:\n" +
                    "  -ignoremove   Igmore moved code. Default behaviour is to count moved code as changed.\n" +
                    "  -verbose      Output more detailed metrics\n";

    CodeMetrics() {
        oldFiles = new SourceFiles();
        newFiles = new SourceFiles();
    }

    public static void main(final String[] args) {
        CodeMetrics codeMetrics = new CodeMetrics();

        codeMetrics.parseCommandLine(args);

        // Calculate Cyclomatic Complexity
        System.out.println("complex");
        codeMetrics.newFiles.countComplexity();
        System.out.println("lines");
        // Count LOC (Lines of Code)
        codeMetrics.newFiles.countLines();

        // Calculate Code Churn
        if (codeMetrics.calculateCodeChurn) {
            DiffDir d = new DiffDir();
            System.out.println("diff");
            d.diffDirsAndCountCodeChurn(codeMetrics.oldFiles, codeMetrics.newFiles);
            System.out.println("graph");
            XYPlotCodeChurn demo = new XYPlotCodeChurn("Code churn vs avg complexity");
            for (int i = 0; i < codeMetrics.newFiles.getNrOfFiles(); i++) {
                if (!codeMetrics.newFiles.getSrcFile(i).isEqual()) {
                    if (codeMetrics.newFiles.getSrcFile(i).getCodeChurn()>20) {
                        demo.addFileMeasurement(codeMetrics.newFiles.getSrcFile(i).getAvgComplexity(), codeMetrics.newFiles.getSrcFile(i).getLinesOfStatements(), codeMetrics.newFiles.getSrcFile(i).getCodeChurn(), codeMetrics.newFiles.getSrcFile(i).getFileName());
                    }
                }
            }
            demo.saveGraph();

            //demo.showGraph();
        }

        Reporting r = new Reporting();

//        r.printReport(codeMetrics.newFiles,codeMetrics.calculateCodeChurn); //to System.out
        r.printOverallStatistics(codeMetrics.newFiles,codeMetrics.calculateCodeChurn); //aggregated statistics to System.out
        r.writeReport(codeMetrics.newFiles, codeMetrics.calculateCodeChurn); //to File
        r.writeAggregatedReport(codeMetrics.newFiles, codeMetrics.calculateCodeChurn); //to File


    }


    private void parseCommandLine(final String[] args) {
        // Check if we have a parameter
        if (args.length == 0) {
            System.out.println(usage);
            System.exit(1);
        }
        // One parameter (Run Code Metrics without Code Churn)
        else if (args.length == 1) {
            newFile = new File(args[0]);

            if (newFile.isDirectory()) {
                // One directory
                newFiles.parseSrcDir(newFile);
            } else if (newFile.isFile()) {
                // One file
                newFiles.addSrcFile(newFile);
            } else {
                System.out.println(usage);
                System.exit(1);
            }
        }
        // Two parameters calculate all Code Metrics
        else if (args.length == 2) {
            oldFile = new File(args[0]);
            newFile = new File(args[1]);
            calculateCodeChurn = true;

            if (oldFile.isDirectory() && newFile.isDirectory()) {
                // Two directories
                newFiles.parseSrcDir(newFile);
                oldFiles.parseSrcDir(oldFile);
                newFiles.setPath(newFile.getAbsolutePath());
                oldFiles.setPath(oldFile.getAbsolutePath());
            } else if (oldFile.isFile() && newFile.isFile()) {
                // Two files
                oldFiles.addSrcFile(oldFile);
                newFiles.addSrcFile(newFile);
            } else {
                System.out.println(usage);
                System.exit(1);
            }
        }
    }
}


//public class XDirDiff {
//  static void Main(string[] args)
//  {
//
//    // Create two identical or different temporary folders  
//    // on a local drive and change these file paths. 
//    string pathA = @"C:\TestDir";
//    string pathB = @"C:\TestDir2";
//
//    System.IO.DirectoryInfo dir1 = new System.IO.DirectoryInfo(pathA);
//    System.IO.DirectoryInfo dir2 = new System.IO.DirectoryInfo(pathB);
//
//    // Take a snapshot of the file system.
//    IEnumerable<System.IO.FileInfo> list1 = dir1.GetFiles("*.*", System.IO.SearchOption.AllDirectories);
//    IEnumerable<System.IO.FileInfo> list2 = dir2.GetFiles("*.*", System.IO.SearchOption.AllDirectories);
//
//    //A custom file comparer defined below
//    FileCompare myFileCompare = new FileCompare();
//
//    // This query determines whether the two folders contain 
//    // identical file lists, based on the custom file comparer 
//    // that is defined in the FileCompare class. 
//    // The query executes immediately because it returns a bool. 
//    bool areIdentical = list1.SequenceEqual(list2, myFileCompare);
//
//    if (areIdentical == true)
//    {
//      Console.WriteLine("the two folders are the same");
//    }
//    else
//    {
//      Console.WriteLine("The two folders are not the same");
//    }
//
//    // Find the common files. It produces a sequence and doesn't  
//    // execute until the foreach statement. 
//    var queryCommonFiles = list1.Intersect(list2, myFileCompare);
//
//    if (queryCommonFiles.Count() > 0)
//    {
//      Console.WriteLine("The following files are in both folders:");
//      foreach (var v in queryCommonFiles)
//      {
//        Console.WriteLine(v.FullName); //shows which items end up in result list
//      }
//    }
//    else
//    {
//      Console.WriteLine("There are no common files in the two folders.");
//    }
//
//    // Find the set difference between the two folders. 
//    // For this example we only check one way. 
//    var queryList1Only = (from file in list1
//        select file).Except(list2, myFileCompare);
//
//    Console.WriteLine("The following files are in list1 but not list2:");
//    foreach (var v in queryList1Only)
//    {
//      Console.WriteLine(v.FullName);
//    }
//
//    // Keep the console window open in debug mode.
//    Console.WriteLine("Press any key to exit.");
//    Console.ReadKey();
//  }
//}
//
//// This implementation defines a very simple comparison 
//// between two FileInfo objects. It only compares the name 
//// of the files being compared and their length in bytes. 
//class FileCompare : System.Collections.Generic.IEqualityComparer<System.IO.FileInfo>
//{
//  public FileCompare() { }
//
//  public bool Equals(System.IO.FileInfo f1, System.IO.FileInfo f2)
//  {
//    return (f1.Name == f2.Name &&
//        f1.Length == f2.Length);
//  }
//
//  // Return a hash that reflects the comparison criteria. According to the  
//  // rules for IEqualityComparer<T>, if Equals is true, then the hash codes must 
//  // also be equal. Because equality as defined here is a simple value equality, not 
//  // reference identity, it is possible that two or more objects will produce the same 
//  // hash code. 
//  public int GetHashCode(System.IO.FileInfo fi)
//  {
//    string s = String.Format("{0}{1}", fi.Name, fi.Length);
//    return s.GetHashCode();
//  }
//}
//}
